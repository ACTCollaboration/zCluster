#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
    Copyright 2016 Matt Hilton (matt.hilton@mykolab.com)
    
    This file is part of zCluster.

    zCluster is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    zCluster is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with zCluster.  If not, see <http://www.gnu.org/licenses/>.

"""

import os
import sys
import argparse
import astropy.table as atpy
from zCluster import *
import pylab as plt
import numpy as np
import IPython
plt.matplotlib.interactive(False)

# For MNRAS
#plt.matplotlib.rcParams['pdf.fonttype'] = 42
#plt.matplotlib.rcParams['ps.fonttype'] = 42

# For some unknown reason, mathtext in matplotlib is behaving weirdly since Ubuntu 16.10 upgrade
#try:
    #plt.matplotlib.rc('text', usetex=True)
#except:
    #pass

#------------------------------------------------------------------------------------------------------------
def update_rcParams(dict={}):
    """
    Based on Cristobal's preferred settings.
    
    """
    default = {}
    for tick in ('xtick', 'ytick'):
        default['{0}.major.size'.format(tick)] = 8
        default['{0}.minor.size'.format(tick)] = 4
        default['{0}.major.width'.format(tick)] = 2
        default['{0}.minor.width'.format(tick)] = 2
        default['{0}.labelsize'.format(tick)] = 20
        default['{0}.direction'.format(tick)] = 'in'
    default['xtick.top'] = True
    default['ytick.right'] = True
    default['axes.linewidth'] = 2
    default['axes.labelsize'] = 22
    default['font.size'] = 22
    default['font.family']='sans-serif'
    default['legend.fontsize'] = 18
    default['lines.linewidth'] = 2

    for key in default:
        plt.rcParams[key] = default[key]
    # if any parameters are specified, overwrite anything previously
    # defined
    for key in dict:
        plt.rcParams[key] = dict[key]
        
#-------------------------------------------------------------------------------------------------------------
if __name__ == '__main__':

    parser = argparse.ArgumentParser("zClusterComparisonPlot")
    parser.add_argument("inCatalog", help="""A .fits table or a .csv file with columns 'name', 'RADeg',
                        'decDeg', 'z'. The last column here is the redshift which is for comparison with
                        the zCluster output. Objects are matched against zClusterCatalog based on the 'name'
                        columns.""")
    parser.add_argument("zClusterCatalog", help="""Path to a zCluster .fits table, i.e., the output of
                        the zCluster code.""")
    parser.add_argument("-o", "--output-label", dest="outLabel", help="""Label to use for output  
                        (default: comparison_inCatalogFileName_zClusterCatalog, stripped of file extension). 
                        The code will write both a plot (.pdf) and a .fits table in the current
                        directory. Note that '.' in outLabel will be replaced with 'p' in the plot
                        file name in order to be latex friendly.""", default = None)
    parser.add_argument("-t", "--title", dest="plotTitle", help="Plot title.", default = None)
    parser.add_argument("-z", "--zmax", dest="zMax", help="""Maximum redshift for statistics 
                        (default: 2.0).""", default = 2.0)
    parser.add_argument("-d", "--deltamin", dest="deltaMin", help="""Minimum delta for statistics 
                        (default: 3.0).""", default = 3.0)
    parser.add_argument("-l", "--inlabel", dest="inLabel", help="""Subscript label for input redshifts
                        (default: s).""", default = "s")
    parser.add_argument("-y", "--yrange", dest="yRangeStr", help="""Range of the plot y-axis (which
                        is the difference between the inCatalog redshift and the redshift in 
                        zClusterCatalog), given in the format yMin:yMax.""", default = "-0.55:0.55")
    args = parser.parse_args()

    inCatalogFileName=args.inCatalog
    outCatalogFileName=args.zClusterCatalog

    if args.plotTitle != None:
        plotTitle=str(args.plotTitle)
    else:
        plotTitle=None
    if args.zMax != None:
        zMax=float(args.zMax)
    if args.deltaMin != None:
        deltaMin=float(args.deltaMin)
    if args.inLabel != None:
        inLabel=str(args.inLabel)
    if args.yRangeStr != None:
        yRangeStr=str(args.yRangeStr)
    else:
        yRangeStr=args.yRangeStr
        
    if inCatalogFileName.split(".")[-1] == "csv":
        inTab=atpy.Table().read(inCatalogFileName, type = 'ascii')
    else:
        inTab=atpy.Table().read(inCatalogFileName)
        
    outTab=atpy.Table().read(outCatalogFileName)

    if args.outLabel == None:
        outFileName="comparison_"+os.path.split(inCatalogFileName)[-1].replace(".fits", "").replace(".csv", "")+"_vs_"+outCatalogFileName
    else:
        outFileName=outLabel+".fits"
    plotFileName=outFileName.replace(".fits", "")
    plotFileName=plotFileName.replace(".", "p")+".pdf"

    if 'z' in inTab.keys():
        zKey='z'
    elif 'redshift' in inTab.keys():
        zKey='redshift'
    else:
        raise Exception, "didn't find 'z' or 'redshift' column in input table %s" % (inCatalogFileName)
    
    # Match on names
    outTab.add_column(atpy.Column(np.zeros(len(outTab)), "zIn"))
    for irow in inTab:
        for orow in outTab:
            if str(irow['name']) == str(orow['name']):
                orow['zIn']=irow[zKey]
    tab=outTab[np.where(outTab['zIn'] > 0.0)]
    tab.add_column(atpy.Column(tab['zIn']-tab['z'], 'zDiff'))
    tab=tab[np.where(tab['z'] > 0)] # because filled in -99 for fails/missing clusters (e.g., not in S82)
    
    zIn=tab['zIn']
    zOut=tab['z']
    delta=tab['delta']
    diff=tab['zDiff']
    diff_over1plusz=diff/(1+tab['zIn'])
    odds=tab['odds']
    
    ## Stats based on zPriorCut (needs to be given since we don't know it here)
    #if zMax != None:
        #print ">>> Stats for zIn < %.2f:" % (zMax)
        #mask=np.less(zIn, zMax)
        #maskedDiff=zIn[mask]-zOut[mask]
        #meanMaskedDiff=np.mean(maskedDiff)
        #stdMaskedDiff=np.std(maskedDiff)
        #print "... median (zIn - zOut) = %.3f" % (np.median(maskedDiff))
        #print "... mean (zIn - Zout) = %.3f" % (meanMaskedDiff)
        #print "... sigma (zIn - zOut) = %.3f" % (stdMaskedDiff)
        #print "... N = %d ..." % (len(maskedDiff))

    ## Stats based on odds cut
    #oddsMin=0.35
    #print ">>> Stats for odds > %.2f:" % (oddsMin)
    #mask=np.greater(odds, oddsMin)
    #notMask=np.less(odds, oddsMin)
    #maskedDiff=zIn[mask]-zOut[mask]
    #meanMaskedDiff=np.mean(maskedDiff)
    #stdMaskedDiff=np.std(maskedDiff)
    #print "... median (zIn - zOut) = %.3f" % (np.median(maskedDiff))
    #print "... mean (zIn - Zout) = %.3f" % (meanMaskedDiff)
    #print "... sigma (zIn - zOut) = %.3f" % (stdMaskedDiff)
        
    # Stats based on delta cut by z
    zCutsList=[[0.0, 2.0],[0.1, 0.5],[0.5, 1.0], [0.5, 1.5], [1.0, 2.0]]
    if deltaMin != None:
        print ">>> Stats for delta > %.2f:" % (deltaMin)
        for zCuts in zCutsList:
            zMin=zCuts[0]
            zMax=zCuts[1]
            deltaMask=np.greater(delta, deltaMin)
            notMask=np.less(delta, deltaMin)
            zMask=np.logical_and(np.greater(zIn, zMin), np.less(zIn, zMax))
            mask=np.logical_and(zMask, deltaMask)
            if mask.sum() > 0:
                print "--> %.2f < z < %.2f (N = %d):" % (zMin, zMax, mask.sum())
                maskedDiff=zIn[mask]-zOut[mask]
                meanMaskedDiff=np.mean(maskedDiff)
                stdMaskedDiff=np.std(maskedDiff)
                maskedDiff_over1plusz=(zIn[mask]-zOut[mask])/(1+zIn[mask])
                meanMaskedDiff_over1plusz=np.mean(maskedDiff_over1plusz)
                stdMaskedDiff_over1plusz=np.std(maskedDiff_over1plusz)
                print "... median (zIn - zOut) = %.3f" % (np.median(maskedDiff))
                print "... mean (zIn - Zout) = %.3f +/- %.3f" % (meanMaskedDiff, stdMaskedDiff / np.sqrt(mask.sum()))
                print "... sigma (zIn - zOut) = %.3f" % (stdMaskedDiff)
                if zCuts == zCutsList[0]:
                    print "... median (zIn - zOut) / (1 + zIn) = %.3f" % (np.median(maskedDiff_over1plusz))
                    print "... mean (zIn - Zout) / (1 + zIn)  = %.3f" % (meanMaskedDiff_over1plusz)
                    print "... sigma (zIn - zOut) / (1 + zIn)  = %.3f" % (stdMaskedDiff_over1plusz)

    # Default mask / stats for plotting
    zMin=zCutsList[0][0]
    zMax=zCutsList[0][1]
    deltaMask=np.greater(delta, deltaMin)
    notMask=np.less(delta, deltaMin)
    zMask=np.logical_and(np.greater(zIn, zMin), np.less(zIn, zMax))
    mask=np.logical_and(zMask, deltaMask)
    maskedDiff=zIn[mask]-zOut[mask]
    meanMaskedDiff=np.mean(maskedDiff)
    stdMaskedDiff=np.std(maskedDiff)
    maskedDiff_over1plusz=(zIn[mask]-zOut[mask])/(1+zIn[mask])
    meanMaskedDiff_over1plusz=np.mean(maskedDiff_over1plusz)
    stdMaskedDiff_over1plusz=np.std(maskedDiff_over1plusz)
    
    # Plot                
    update_rcParams()
    
    plt.figure(figsize=(18, 6.5))

    plt.subplot(121)
    plt.subplots_adjust(left = 0.065, bottom = 0.11, right = 0.99, top = 0.97, wspace = 0.01, hspace = 0.24)
    
    plt.plot(zIn[notMask], diff_over1plusz[notMask], 'wD', mec = 'k', ms = 8, label = '$\delta < %.0f$' % (deltaMin))
    plt.plot(zIn[deltaMask], diff_over1plusz[deltaMask], 'D', ms = 8, label = '$\delta > %.0f$' % (deltaMin))
    yPlotRange=np.linspace(-1, 1, 10)
    xPlotRange=np.linspace(0, zIn.max()*1.1, 10)
    plt.plot(xPlotRange, [meanMaskedDiff]*len(xPlotRange), 'k--', 
             label = '$\langle \, (z_{\mathrm{%s}}$-$z_{\mathrm{c}}$)/($1+z_{\mathrm{%s}}) \, \\rangle$ = %.3f' % (inLabel, inLabel, meanMaskedDiff_over1plusz))
    plt.plot(xPlotRange, [meanMaskedDiff-stdMaskedDiff]*len(xPlotRange), 'k:', 
             label = '$\sigma$ [($z_{\mathrm{%s}}$-$z_{\mathrm{c}}$)/($1+z_{\mathrm{%s}}$)] = %.3f' % (inLabel, inLabel, stdMaskedDiff_over1plusz))
    plt.plot(xPlotRange, [meanMaskedDiff+stdMaskedDiff]*len(xPlotRange), 'k:')
    plt.plot(np.linspace(0, zIn.max()*1.1, 3), [0]*3, 'k-')
    plt.xlim(0, zIn.max()*1.1)
    if yRangeStr != None:
        yMin, yMax=yRangeStr.split(":")
        yMin=float(yMin)
        yMax=float(yMax)
        plt.ylim(yMin, yMax)
    leg=plt.legend(numpoints = 1, loc = 'lower right')
    if plotTitle != None:
        plt.figtext(0.1, 0.85, plotTitle, fontdict = {'size': 28, 'weight': 'bold'}, ha = 'left')#, size = 24)
    #leg.draw_frame(False)
    yticks, ylabels=plt.yticks()
    plt.xlabel("$z_{\mathrm{%s}}$" % (inLabel))
    plt.ylabel("$(z_{\mathrm{%s}}-z_{\mathrm{c}})$/$(1+z_{\mathrm{%s}})$" % (inLabel, inLabel))

    plt.subplot(122)
    plt.plot(delta[notMask], diff_over1plusz[notMask], 'wD', mec = 'k', ms = 8, label = '$\delta$ < $%.0f$' % (deltaMin))
    plt.plot(delta[mask], diff_over1plusz[mask], 'D', ms = 8, label = '$\delta$ > $%.0f$' % (deltaMin))
    yPlotRange=np.linspace(-1, 1, 10)
    xPlotRange=np.linspace(0, delta.max()*1.1, 10)
    plt.plot(xPlotRange, [meanMaskedDiff]*len(xPlotRange), 'k--', 
             label = 'mean($z_{\mathrm{%s}}$-$z_{\mathrm{c}}$) = %.3f' % (inLabel, meanMaskedDiff_over1plusz))
    plt.plot(xPlotRange, [meanMaskedDiff-stdMaskedDiff]*len(xPlotRange), 'k:', 
             label = '$\sigma$($z_{\mathrm{%s}}$-$z_{\mathrm{c}}$) = %.3f' % (inLabel, stdMaskedDiff_over1plusz))
    plt.plot(xPlotRange, [meanMaskedDiff+stdMaskedDiff]*len(xPlotRange), 'k:')
    plt.plot(np.linspace(0, delta.max()*1.1, 3), [0]*3, 'k-')
    plt.xlim(0, delta.max()*1.1)
    plt.yticks(yticks, len(yticks)*[''])
    if yRangeStr != None and yRangeStr != 'auto':
        yMin, yMax=yRangeStr.split(":")
        yMin=float(yMin)
        yMax=float(yMax)
        plt.ylim(yMin, yMax)
    plt.xlabel("$\delta$")
    #plt.ylabel("$(z_{\mathrm{%s}}-z_{\mathrm{c}})$/$(1+z_{\mathrm{%s}})$" % (inLabel, inLabel))

    plt.savefig(plotFileName)
    plt.close()
    
    # Output for more fiddling
    tab.table_name="zCluster comparison"
    if os.path.exists(outFileName) == True:
        os.remove(outFileName)
    tab.write(outFileName)
    

    
