#!/usr/bin/env python

"""

Fetch photometry for galaxy fields from photometric databases at given position and radius.

"""

import os
import sys
import argparse
import numpy as np
import astropy.table as atpy
import astropy.io.fits as pyfits
import astropy.stats as apyStats
from astLib import *
from zCluster import catalogRetriever
from zCluster import PhotoRedshiftEngine
from zCluster import clusterFinding
import urllib
import time
import IPython


start=time.time()
if __name__ == '__main__':

    parser = argparse.ArgumentParser("zField")
    parser.add_argument("RADeg", type = float, help="""RADeg for the field to fetch.""")
    parser.add_argument("decDeg", type = float, help="""decDeg for the field to fetch.""")
    parser.add_argument("-r", "--max-radius-deg", dest="maxRDeg", help="""Maximum radius in degrees of the
                        galaxy field to fetch. Default = 0.2""", type = float, default = 0.2)
    parser.add_argument("-D", "--database", help="""The photometric database to use. Options are 'SDSSDR12', 'S82' 
                        (for SDSS DR7 Stripe 82 co-add); 'CFHTLenS'; 'DESDR1' [experimental], 
                        'DESY3' [experimental; requires access to proprietary DES data]; 'PS1' [experimental]; 
                        'DECaLS' (DR8) [experimental]; or the path to a .fits table with columns in the 
                        appropriate format ('ID', 'RADeg', 'decDeg', and magnitude column names in the form 
                        'u_MAG_AUTO', 'u_MAGERR_AUTO' etc.).""", default = 'DECaLS')
    parser.add_argument("-c", "--cachedir", dest="cacheDir",help="""Cache directory location
                        (default: $HOME/.zCluster/cache). Downloaded photometric catalogs will be stored
                        here.""")
    parser.add_argument("-o", "--output-directory", dest="outDir", help="""Label to use for the preferred output
                        directory.""", default = "zFieldOutput")
    parser.add_argument("-t", "--templates-directory", dest="templatesDir", help="""Specify a directory containing
                        a custom set of spectral templates.""",
                        default = None)
    parser.add_argument("-e", "--max-mag-error", dest="maxMagError", help="""Maximum acceptable 
                        photometric error (in magnitudes; default: 0.25).""", default = 0.25)
    parser.add_argument("-E", "--photometric-zero-point-error", dest="ZPError", type = float,
                        help="""Global photometric zero point uncertainty in magnitudes, applied to all bands
                        (default: 0). Added in quadrature to the photometric uncertainties in the catalog.""",
                        default = 0.02)
    parser.add_argument("-f", "--fit-for-zero-point-offsets", dest="fitZPOffsets", 
                        help="""If the input catalog contains a z_spec column, use those galaxies to fit
                        for magnitude zero point offsets. These will then be applied when estimating galaxy
                        photometric redshifts.""", 
                        default = False, action = "store_true")
    parser.add_argument("-b", "--brighter-absmag-cut", dest="absMagCut", help="""Set bright absolute magnitude cut.""", 
                        default = -24.)
    parser.add_argument("-d", "--write-density-maps", dest="writeDensityMaps", action="store_true", 
                        help="""Write out a .fits image projected density map (within delta z = +/- 0.1 of the best 
                        fit redshift) for each cluster.""",
                        default = False)
    parser.add_argument("-z", "--redshift", dest="z", help="""Galaxy redshift at which to make a density map""", type = float,
                        default = None)
    parser.add_argument("-delta_z", "--delta-z", dest="dz", help="""Make a projected density map within +/- dz of the
                        given redshift.""", type = float, default = None)

    args = parser.parse_args()

    RADeg=args.RADeg
    decDeg=args.decDeg
    maxRDeg=args.maxRDeg
    ZPError=args.ZPError
    templatesDir=args.templatesDir
    absMagCut=args.absMagCut
    database=args.database
    maxMagError=args.maxMagError
    fitZPOffsets=args.fitZPOffsets
    cacheDir=args.cacheDir
    writeDensityMaps=args.writeDensityMaps
    z=args.z
    dz=args.dz

    # Set-up cache
    if cacheDir is not None:
        os.makedirs(cacheDir, exist_ok=True)
    else:
        cacheDir=catalogRetriever.CACHE_DIR
    os.makedirs(cacheDir, exist_ok  = True)

    # Set-up where we will write output
    os.makedirs(args.outDir, exist_ok = True)
    outFileName=args.outDir+os.path.sep+"zField_catalog_%.3f_%.3f.fits" % (RADeg, decDeg)
    
    
    # Default prior cuts are defined for each database here... 
    # Can be overridden with args.zPriorMin, args.zPriorMax... see below
    retrieverOptions={}
    passbandSet='SDSS+Ks'
    
    zDebias=None    # A fudge used to correct output zs for some surveys (final z = z + zDebias*(1+z))
    ZPOffsets=None
    if database == 'S82':
        retriever=catalogRetriever.S82Retriever
        zPriorMin=0.20
        zPriorMax=1.5
        retrieverOptions={'maxMagError': maxMagError}
    elif database == 'SDSSDR7':
        retriever=catalogRetriever.SDSSDR7Retriever
    elif database == 'SDSSDR8':
        retriever=catalogRetriever.SDSSDR8Retriever
    elif database == 'SDSSDR10':
        retriever=catalogRetriever.SDSSDR10Retriever
    elif database == 'SDSSDR12':
        retriever=catalogRetriever.SDSSDR12Retriever
        zPriorMin=0.05
        zPriorMax=0.8
        retrieverOptions={'maxMagError': maxMagError}
    elif database == 'PS1':
        import mastcasjobs
        if not os.environ.get('CASJOBS_WSID'):
            raise Exception("Set CASJOBS_WSID environment variable to use PS1 (see: http://ps1images.stsci.edu/ps1_dr2_query.html - to get your WSID, go to http://mastweb.stsci.edu/ps1casjobs/ChangeDetails.aspx and check your 'profile' page)")
        if not os.environ.get('CASJOBS_PW'):
            raise Exception("Set CASJOBS_PW environment variable to use PS1 (see: http://ps1images.stsci.edu/ps1_dr2_query.html)")
        retriever=catalogRetriever.PS1Retriever
        # Min prior here set to match 4 Mpc max search radius
        zPriorMin=0.15
        zPriorMax=0.6
        passbandSet='PS1'
        retrieverOptions={'maxMagError': maxMagError, 'jobs': mastcasjobs.MastCasJobs(context="PanSTARRS_DR2")}
    elif database == 'DESY3':
        import easyaccess as ea
        connection=ea.connect(section = 'dessci')
        #connection=None
        retriever=catalogRetriever.DESY3Retriever
        zPriorMin=0.05
        zPriorMax=1.5
        passbandSet='DES'
        retrieverOptions={'maxMagError': maxMagError, 'connection': connection}
        zDebias=0.02    # From testing against spec-zs (don't know yet why there is a mean offset)
    elif database == 'DESY3+WISE':
        import easyaccess as ea
        connection=ea.connect(section = 'dessci')
        retriever=catalogRetriever.DESY3WISERetriever
        zPriorMin=0.05
        zPriorMax=1.5
        passbandSet='DES+WISE'
        retrieverOptions={'maxMagError': maxMagError, 'connection': connection}
        zDebias=0.02    # From testing against spec-zs (don't know yet why there is a mean offset)
    elif database == 'DESDR1':
        import easyaccess as ea
        connection=ea.connect(section = 'desdr')
        retriever=catalogRetriever.DESDR1Retriever
        zPriorMin=0.05
        zPriorMax=1.5
        passbandSet='DES'
        retrieverOptions={'maxMagError': maxMagError, 'connection': connection}
    elif database == 'KiDSDR4':
        retriever=catalogRetriever.KiDSDR4Retriever
        zPriorMin=0.05
        zPriorMax=1.5
        passbandSet='KiDS-VIKING'
        zDebias=0.02    # From testing against spec-zs (don't know yet why there is a mean offset)
        retrieverOptions={'maxMagError': maxMagError}
    elif database == 'ATLASDR4':
        retriever=catalogRetriever.ATLASDR4Retriever
        zPriorMin=0.05
        zPriorMax=0.8
        passbandSet='KiDS-VIKING'
        retrieverOptions={'maxMagError': maxMagError}
    elif database == 'CFHTLenS':
        retriever=catalogRetriever.CFHTLenSRetriever
        zPriorMin=0.05
        zPriorMax=1.5
        retrieverOptions={'maxMagError': maxMagError}
    elif database == 'DECaLS':
        # For DECaLS, need the bricks files that define survey on the sky
        # These were previously included in zCluster, but now we fetch over web and cache
        bricksCacheDir=catalogRetriever.CACHE_DIR
        catalogRetriever.makeCacheDir()
        bricksPath=bricksCacheDir+os.path.sep+"survey-bricks.fits.gz"
        if os.path.exists(bricksPath) == False:
            print("... fetching and caching DECaLS survey-bricks.fits.gz ...")
            urllib.request.urlretrieve("http://portal.nersc.gov/project/cosmo/data/legacysurvey/dr8/survey-bricks.fits.gz", bricksPath)
        bricksDR8Path=bricksCacheDir+os.path.sep+"survey-bricks-dr8-south.fits.gz"
        if os.path.exists(bricksDR8Path) == False:
            print("... fetching and caching DECaLS survey-bricks-dr8-south.fits.gz ...")
            urllib.request.urlretrieve("https://portal.nersc.gov/project/cosmo/data/legacysurvey/dr8/south/survey-bricks-dr8-south.fits.gz", bricksDR8Path)
        bricksTab=atpy.Table().read(bricksPath)
        DR8Tab=atpy.Table().read(bricksDR8Path)
        DR8Tab.rename_column("brickname", "BRICKNAME")
        retriever=catalogRetriever.DECaLSRetriever
        zPriorMin=0.05
        zPriorMax=1.5
        #maxMagError=0.2
        passbandSet='DECaLS'
        # Zero point offsets had no effect on correcting the bias
        #ZPOffsets=np.array([-0.00878495, -0.019883, 0.01998477, -0.03047624, 0.00860256])
        #ZPOffsets=np.array([-0.00380799, -0.01845335, 0.01706214, -0.0291939, 0.01454793])
        #ZPOffsets=np.array([-0.07441184, -0.04284442, 0.01009525, 0.01008043, 0.05755784]) 
        #ZPOffsets=np.array([0.02271222, -0.05051711, -0.02465597, -0.00406835, 0.05406105])
        zDebias=0.02    # From testing against spec-zs (don't know yet why there is a mean offset)
        retrieverOptions={'maxMagError': maxMagError, 'bricksTab': bricksTab, 'DR8Tab': DR8Tab, 'altCacheDir': "DECaLSCache"}
    elif database == 'CFHTDeep':
        retriever=catalogRetriever.CFHTDeepRetriever
    elif database == 'CFHTWide':
        retriever=catalogRetriever.CFHTWideRetriever
        zPriorMin=0.05
        zPriorMax=1.5
        
    galaxyCatalog=retriever(RADeg, decDeg, halfBoxSizeDeg = maxRDeg, optionsDict = retrieverOptions)

    if galaxyCatalog is None:
        print("No galaxies found at the given position..")
        sys.exit()
    
    photoRedshiftEngine=PhotoRedshiftEngine.PhotoRedshiftEngine(absMagCut, ZPError = ZPError, passbandSet = passbandSet,
                                                                templatesDir = templatesDir, ZPOffsets = ZPOffsets)
    bands=photoRedshiftEngine.bands
    bandErrs=[]
    for b in bands:
        bandErrs.append(b+"Err")
    bands=bands+bandErrs

    if fitZPOffsets == True:
        photoRedshiftEngine.calcZeroPointOffsets(galaxyCatalog)
    photoRedshiftEngine.calcPhotoRedshifts(galaxyCatalog, calcMLRedshiftAndOdds = True)

    for gobj in galaxyCatalog:
        if 'r' in list(gobj.keys()) and 'i' in list(gobj.keys()):
            gobj['r-i']=gobj['r']-gobj['i']
        if 'r' in list(gobj.keys()) and 'z' in list(gobj.keys()):
            gobj['r-z']=gobj['r']-gobj['z']
       
            
    wantedKeys=['id', 'RADeg', 'decDeg', 'zPhot', 'odds']
    wantedKeys=np.concatenate((wantedKeys,bands))
    tab=atpy.Table()
    for key in wantedKeys:
        arr=[]
        for gobj in galaxyCatalog:
            try:
                arr.append(gobj[key])
            except:
                arr.append(99)
        tab.add_column(atpy.Column(np.array(arr), key))
    tab.write(outFileName, overwrite = True)
        
    if writeDensityMaps == True:
        if z == None and dz == None:
            raise Exception("-z and -delta_z need to be given when using the -d option")
        else:
            dMapDict = clusterFinding.makeDensityMap(RADeg, decDeg, galaxyCatalog, z, dz, rMaxMpc = 1.5)
            astImages.saveFITS(args.outDir+os.path.sep+"densityMap_z%s_%.3f_%.3f.fits" % (z, RADeg, decDeg),
                               dMapDict['map'], dMapDict['wcs'])
    
    # We may as well print some stats
    print(">>> Summary:")
    print("    N = %d" %  (len(tab['zPhot'])))
    print("    ")
    print(">>> Catalog fetching is complete.")
    print(">>> Total time: {:.1g} minutes".format((time.time()-start)/60.))